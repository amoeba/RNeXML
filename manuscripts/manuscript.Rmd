---
#layout: preprint
layout: review, 11pt
title: "RNeXML: a package for reading and writing richly annotated phylogenetic, character, and trait data in R"
author: 
  - name: Carl Boettiger
    affiliation: cstar
    email: cboettig(at)gmail.com
    footnote: Corresponding author
  - name: Hilmar Lapp
    affiliation: NESCent
  - name: Scott Chamberlain
    affiliation: ropensci
  - name: Rutger Vos
    affiliation: NBC
address: 
  - code: cstar
    address: | 
      Center for Stock Assessment Research, 
      Department of Applied Math and Statistics, 
      University of California, Mail Stop SOE-2,
      Santa Cruz, CA 95064, USA
  - code: NESCent
    address: | 
      National Evolutionary Synthesis Center, Durham, NC, USA
  - code: ropensci
    address: |
      University of California, Berkeley, CA, USA
  - code: NBC
    address: | 
      Naturalis Biodiversity Center, Leiden, the Netherlands
abstract: | 
      1. NeXML is a new exchange format for phylogenetic data and
      metadata that offers substantial improvements in reliability,
      extensibility, and richness over earlier formats such as
      NEXUS. In this paper we present the RNeXML package which
      provides a bridge between this data format and the extensive
      library of phylogenetic tools already available in the popular
      data analysis environment and programming language R, with a
      particular emphasis on comparative methods.

      2. The ability to parse and write NeXML from within R is only a
      small part of the functionality offered by the package.  We
      illustrate how RNeXML facilitates adding and manipulating data
      annotations whose meaning can be defined in a precise and
      machine-interpretable way by means of formal ontologies and other
      semantic web technologies.

      3. An essential feature of NeXML is to provide both the
      flexibility to be continually extended to meet the emerging
      needs of the phylogenetics community without breaking software
      unaware of such extensions. We illustrate how RNeXML makes
      it easy to extend NeXML in this manner.
      
      4. RNeXML is well suited for users to preserve and maintain
      their personal archives of phylogenetic and comparative trait
      data in consistent, query-able, and cross-platform format, to
      leverage the rapidly growing public community archives of rich
      NeXML files, and to interact with web services that return data
      and their metadata packaged together as NeXML.

bibliography: components/references.bib
csl: components/methods-in-ecology-and-evolution.csl
documentclass: components/elsarticle

output: 
  pdf_document:
    template: components/elsarticle.latex
    keep_tex: true
    fig_caption: true


---

<!------------------------------------------------

Map/Outline:
------------

- Introduction
  - Exciting times in phylogenetics!  
  - Challenges with existing formats 
  - Overview of NeXML
  - Challenges with R
  - Map 

- Tutorial
  - Reading Phylogenetic trees
  - Reading Character data
  - Writing phylogenetic trees & character data

  - Metadata
    - Adding basic metadata
    - Adding taxonomic identifiers
    - Adding Generic metadata
    - Parsing metadata. XML. RDF.
    - Extending NeXML with metadata: Example defining simmap stochastic character mappings.  

  - Publishing NeXML 

- Implementation, Quality Control
- Software reuse and support

------------------------------------------------>





```{r compile-settings, include=FALSE}
library("methods")
library("knitr")
opts_chunk$set(tidy = FALSE, warning = FALSE, message = FALSE, 
               cache = 1, comment = NA, verbose = TRUE)
basename <- gsub(".Rmd", "", knitr:::knit_concord$get('infile')) 
opts_chunk$set(fig.path = paste("components/figure/", basename, "-", sep=""),
               cache.path = paste("components/cache/", basename, "/", sep=""))


```

# Introduction

Users of the popular statistical and mathematical computing platform R
[@R] enjoy a wealth of readily installable comparative phylogenetic
methods and tools <!-- needs a citation to support it -->. Exploiting
the opportunities arising from this wealth for complex and integrative
comparative research questions relies on the ability to reuse and
integrate previously generated or published data and metadata. The
resulting expanding data exchange needs of the evolutionary research
community are rapidly outpacing the capabilities of the currently
still most widely used data exchange standards, which were all
developed a decade or more ago. This has resulted in a radiation of
different data representations and exchange standard "flavors" that
are no longer interoperable at the very time when the growth of
available data and methods has made that interoperability most
valuable. In response to the unmet needs for standardized data
exchange in phylogenetics, a modern XML-based exchange standard,
called NeXML, has recently been developed [@Vos_2012], and is
beginning to be adopted. NeXML comprehensively supports current data
exchange needs, is predictably machine-readable, and is forward
compatible. To make the capibilities of NeXML available to R users in
an easy-to-use form, and to lower the hurdles to adoption of the
standard, we present RNeXML, an R package that aims to provide easy
programmatic access to reading and writing NeXML documents, tailored
for the kinds of use-cases that will be common for users and
developers of the wealth of evolutionary, and in particular
comparative analysis methods within the R ecosystem.

The exchange problem for phylogenetic data is particularly acute in
light of the challenges in finding and sharing phylogenetic data
without the otherwise common loss of most data and metadata semantics
[@Drew_2013; @Stoltzfus_2012], or with semantics that is predictably
machine interpretable [@Cranston_2014]. For example, the still popular
NEXUS file format [@Maddison_1997] cannot consistently represent
horizontal gene transfer or ambiguity in reading a character (such as
a DNA sequence base pair).  This has led to modifications of NEXUS in
different ways for different needs, with the unfortunate result that
NEXUS files generated by one program can be incompatible with another
[@Vos_2012]. Without a formal grammar, software based on NEXUS files
may also make inconsistent assumptions about tokens, quoting, or
element lengths.  @Vos_2012 estimates that as many as 15% of the NEXUS
files in the CIPRES portal contain unrecoverable but hard to diagnose
errors.

A detailed account of how the NeXML standard addresses these and other
relevant challenges can be found in @Vos_2012. In brief, NeXML was
designed with the following important properties. First, NeXML is
defined by a precise grammar that can be programmatically
**validated**. This ensures that any NeXML file can be expected to be
parsed and read without errors by any NeXML-compliant software,
provided the file passes validation. Second, NeXML is **extensible**:
a user can define representations of new, previously unanticipated
information (as we will illustrate) without violating its defining
grammar. Third and most importantly, NeXML is **rich in computable
semantics**. The formal semantics used in NeXML is machine-readable in
a predictable manner, and also enables machine reasoning about the
data and metadata (see @Parr2011), especially when metadata attributes
and values are anchored in appropriately axiomatized ontologies.

`RNeXML` not only allows R's ecosystem to read and write data in
the NeXML format through an interface that is no more involved than
reading or writing data from other phylogenetic data formats, but also
carries immediate benefits for its users. For example, comparative
analysis R packages and users frequently add their own metadata
annotations to the phylogenies they work with, such as annotations
of species, stochastic character maps, trait values, model estimates
and parameter values. `RNeXML` affords R the capability to harness
machine-readable semantics and an extensible metadata schema to
capture, preserve, and share these and other kinds of information, all
through an API instead of having to understand in detail the schema
underlying the NeXML standard. To assist users in meeting the rising
bar for best practices in data sharing in phylogenetic research
[@Cranston_2014], `RNeXML` captures metadata information from the R
environment to the extent possible, and applies reasonable
defaults. 


# The RNeXML package

The `RNeXML` package is written entirely in R and available under a
CC0 public domain waiver. The current development version can be found
on Github at [https://github.com/ropensci/RNeXML](), and the stable
version can be installed from the CRAN repository:

```r
install.packages("RNeXML", dependencies=TRUE)
```

This will also install its dependencies. Once installed, R scripts
using the library only need to load it:

```{r echo=FALSE}
library(RNeXML)
```

`RNeXML` is part of the rOpenSci project. Users of `RNeXML` are
encouraged to submit bug reports or feature requests in the issues log
on Github, or to contact `ropensci-discuss@googlegroups.com` or the
phylogenetics R users group list at `r-sig-phylo@r-project.org` for
help.

## Representation of NeXML documents in R

Conceptually, a NeXML document has the following components: (1)
phylogeny data, (2) character or trait data in matrix form, (3)
operational taxonomic units (OTUs), and (4) metadata. `RNeXML` defines
the `nexml` object type, which is a representation of the NeXML
document contents. It therefore holds phylogenetic trees as well as
character or trait matrices, and all metadata. This is similar in
design to the classes in the `phylobase` package, which contain trees
and traits but hold only limited metadata [@phylobase], but different
from R object types such as `ape::phylo` (the `phylo` class in the
`ape` package [@Paradis_2004]), which represents trees alone.

When reading and writing NeXML documents, `RNeXML` aims to map their
components to and from, respectively, their most natural
representations in R. Hence, the types of objects accepted or returned
by the package's methods are the `phylo` and `multiPhylo` objects from
the `ape` package [@Paradis_2004] for phylogenies, and R's native
`data.frame` list structure for character matrices.

## Reading phylogenies and character data

The method `nexml_read()` reads NeXML files, either from a local
file, or from a remote location via its URL, and returns an object of
type `nexml` [^2]:

```{r}
nex <- nexml_read("components/trees.xml")
```


To interface conveniently with the many already existing R packages for 
phylogenetics, which conventionally accept phylogenies as `ape::phylo`
objects, the method `get_trees_list()` returns a `ape::multiPhylo`
object, which can be treated as a list of `ape::phylo` objects:

```{r}
phy <- get_trees_list(nex)
```

The `get_trees_list()` method is designed for use in scripts, for
which a consistent and predictable return type (namely a `list` of
`ape::multiPhylo` objects, reflecting the nested structure of NeXML)
is desirable. `RNeXML` also contains a method `get_trees()`, which
is designed for interactive use and returns the R object most
intuitive given the arrangement of phylogeny data in the source NeXML
document. NeXML inherits from NEXUS the ability to contain multiple
phylogenies, and to group sets of phylogenies into "blocks". The
`get_trees()` method will return an `ape::phylo` object if the NeXML
document contains a single phylogeny, an `ape::multiPhylo` object if
it contains multiple phylogenies arranged in a single `trees` block,
and a list of `ape::multiPhylo` objects if it contains multiple
`trees` blocks. This design spares an interactive user from having to
type unnecessary data conversion commands, at the expense of needing
to know which return type to expect (or verifying the type via
introspection commands such as `class()`).

If the location parameter with which the `nexml_read()` method is
invoked is recognized as a URL, the method will automatically download the
document to the local working directory and read it from there. This
gives convenient and rapid access to phylogenetic data published in
NeXML format on the web, such as the content of the
phylogenetic data repository TreeBASE [@Piel_2002]. For
example, the following plots a tree in TreeBASE:

```{r eval=FALSE}
tb_nex <- nexml_read(
"https://raw.github.com/TreeBASE/supertreebase/master/data/treebase/S100.xml")
tb_phy <- get_trees_list(tb_nex)
```

The method `get_characters()` obtains character data matrics from a
`nexml` object, and returns them as a standard `data.frame` R object
with columns as characters and rows as taxa:

```{r }
nex <- nexml_read("components/comp_analysis.xml")
get_characters(nex)
```

A NeXML data matrix can be of molecular (for molecular sequence
alignments), discrete (for most morphological character data), or
continuous type (for many trait data).  Data matrices can be, and
matrices of different data types are required to be separated into
different "blocks", to allow strict validation of data types. Since
the `data.frame` data structure in R has no such constraints, the
`get_characters()` method will combine such blocks as separate columns
into a single `data.frame` object, provided they correspond to the
same taxa. Otherwise, a list of `data.frame`s is returned, with list
elements corresponding to characters blocks. Similar to the methods
for obtaining trees, there is also a method `get_characters_list()`,
which always returns a list of `data.frame`s, one for each character
block.

## Writing phylogenies and character data

The method `nexml_write()` generates a NeXML file from its input parameters. In
its simplest invocation, the method writes a tree to a file:

```{r}
data(bird.orders)
nexml_write(bird.orders, file = "birds.xml")
```

The first argument to `nexml_write()` is an object of type `nexml`, or any
object that can be coerced to it, such as in the above example an
`ape::phylo` phylogeny. Alternatively, passing a `multiPhylo` object
would write a list of phylogenies to the file.

In addition to trees, the `nexml_write()` method also allows to specify
character data as another parameter. The following example uses data
from the comparative phylogenetics R package `geiger` [@Harmon_2008].

```{r}
library("geiger")
data(geospiza)
nexml_write(trees = geospiza$phy, 
            characters = geospiza$dat,
            file="geospiza.xml")
```

## Creating and populating `nexml` objects

Instead of packaging the various components for a NeXML file at the
time of writing the file, `RNeXML` also allows users to create and
iteratively populate an in-memory `nexml` object. The methods to do
this are `add_characters()`, `add_trees()`, and `add_meta()`, for
adding characters, trees, and metadata, respectively. Each of these
functions will automatically create a new nexml object if not supplied
with an existing one as the last (optional) argument.

For example, here we use `add_trees()` to first create a `nexml`
object with the phylogeny data, and then add the character data to it:

```{r}
nexObj <- add_trees(geospiza$phy)
nexObj <- add_characters(geospiza$dat, nexObj)
```

The data with which a `nexml` object is populated need not share the
same OTUs.  `RNeXML` automatically adds new, separate OTU blocks into
the NeXML file for each data matrix and tree that uses a set of OTUs
that differs from others.

Other than storage size, there is no limit to the number of
phylogenies and character matrices that can be included in a
single NeXML file. This allows, for example, to capture samples from a
posterior probability distribution of inferred or simulated phylogenies or
character states in one NeXML file.

## Data documentation and annotation with built-in metadata

NeXML allows attaching metadata ("_annotations_") to any data element,
and even to metadata themselves. Whether at the level of the document
as a whole or the an individual data matrix or phylogeny, metadata can
provide bibliographic and provenance information, for example about
the study as part of which the phylogeny was generated or applied,
which data matrix and which methods were used to generate it. Metadata
can also be attached to very specific elements of the data, such as
specific traits, individual OTUs, nodes, or even edges of the
phylogeny.

NeXML uses the "Resource Description Framework in Annotations" (RDFa),
as described in @Vos_2012 or @W3C_2014, to encode metadata
annotations. This standard provides a precisely specified,
machine-readable format that maintains backwards compatibility with
compliant NeXML parsers (and thus `RNeXML`), because the capacity of a
tool to _parse_ annotations is not predicated on _understanding_
the meaning of annotations it has not seen before.

The burden typically involved with documenting and sharing good
metadata alongside the data remains a significant barrier to increased
sharing and reuse of scientific research [@Tenopir_2011]. To promote
sharing of well-documented phylogenetic data, `RNeXML` aims to
alleviate the burden to recording useful and machine-readable metadata
at several levels.

First, when writing a NeXML file the package adds certain basic
metadata automatically if it has not yet been provided, using default
values consistent with recommended best practices
[@Cranston_2014]. Currently, this includes naming the software
generating the NeXML, a time-stamp of when a tree was produced, and an
open data license.

Second, `RNeXML` provides a simple method, called
`add_basic_metadata()`, to set metadata attributes commonly
recommended to be included with publicly archived or shared data
[@Cranston_2014]. The currently accepted parameters include `title`,
`description`, `creator`, `pubdate`, `rights`, `publisher`, and
`citation`. Behind the scenes the method automatically anchors these
attributes in common vocabularies (such as Dublin Core). 

Third, `RNeXML` includes methods to assist with common cases of adding
metadata to specific elements of the NeXML data that increase the
data's utility for reuse. For example, misspellings and inconsistent
taxonomic names are a frequent source of frustration especially when
recombining phylogenetic data from different sources. These obstacles
can be mitigated by annotating the taxonomic names with identifiers,
which also allows being explicit about the identifier authority being
used. `RNeXML` includes the `taxize_nexml()` method, which uses the R
package `taxize` [@Chamberlain_2013] to match each taxon label against
the NCBI database, and, provided a unique match is found, annotates
the respective OTU with the matching NCBI identifier,.


## Data annotation with custom metadata

The RDFa standard adopted by NeXML (see @Vos_2012) for all metadata
annotations defines the structure and syntax for such annotations, but
does not restrict the content. Specifically, every metadata annotation
consists of a metadata property and a value of the property; the
bearer of the property is determined by where the annotation appears
in the NeXML document (technically, the containing element in the XML
document model). Technically, this structure corresponds directly to
Resource Description Framework (RDF) subject-predicate-object triples.
It therefore allows for arbitrary custom extensions to meet ongoing
scientific needs without requiring modifications (or "extensions") of
the syntax, provided the metadata annotations are cast as RDF triples.

The `RNeXML` methods described above for built-in metadata annotations
perform this cast automatically behind the scenes, including mapping
metadata attributes to terms in requisite common vocabularies (such as
Dublin Core for "title", "creator", etc.) or ontologies. Giving
metadata properties (and sometimes values) as vocabulary or ontology
terms rather than simple text strings is crucial for allowing machines
to not only parse but also interpret and potentially reason over their
semantics. To achieve this benefit for custom metadata extensions, the
user necessarily needs to handle certain technical details from which
the `RNeXML` API shields her otherwise, in particular the vocabularies
or ontologies of metadata terms in the form of globally unique
identifiers (normally HTTP URIs). To be consistent with XML
terminology for more technical users, `RNeXML` calls these
_namespaces_, and their abbreviations _prefixes_. For example, the
namespace for the Dublin Core Metadata Terms vocabulary, commonly
abbreviated with "dc", is "http://purl.org/dc/elements/1.1/". Using
its abbreviation, a metadata property "dc:title" expands to the
identifier "http://purl.org/dc/elements/1.1/title", the identifier for
the term "title" in said vocabulary. When resolved as a HTTP URI, the
identifier resolves to a human and machine-readable
(depending on how the identifier is resolved) definition of precisely
what the term `title` in Dublin Core means. In contrast, just using
the text string "title" could also mean the title of a person, a legal title, the verb title, etc.  Although URI identifiers of metadata
vocabularies and terms are not required to resolve, for machines to
derive the maximum benefit from them, they should resolve to RDF
statements defining their semantics.

`RNeXML` includes methods to obtain and manipulate metadata
properties, values, identifiers, and namespaces. The
`get_namespaces()` method accepts a `nexml` object and returns a list
with element names being the namespace abbreviations and element
values being the corresponding identifiers (typically HTTP URIs) for
all annotations attached to the object or one of the contained data elements:


```{r}
prefixes <- get_namespaces(birds)
prefixes["dc"]
```

The `get_metadata()` method returns, as named list, the metadata
annotations for a given `nexml` object at a given level, with the
whole NeXML document being the default:

```{r}
meta <- get_metadata(birds) 
```

The `level` parameter can be used to extract the metadata objects for
the data at specific levels (such as `"otu"` in the following
example), or by specifying `"all"` to extract all metadata objects:

```{r} 
otu_meta <- get_metadata(birds, level="otu")
```

However, because the returned list does not include the data elements
to which the metadata are attached, using the method in this way is
only useful for identifying which metadata are present and their
values. The recommended approach for accessing the metadata attached
to specific data elements is described below. <!-- or is that in the vignette now? -->

A few select metadata properties for which support is built-in have
dedicated accessor methods, for example the citation:

```{r get_citation}
get_citation(birds)
```

The `meta()` method creates a new metadata object from a poperty name
and content (value). For example, the following creates a modification
date metadata object, using the modificationDate property in the PRISM
vocabulary:


```{r}
modified <- meta(property = "prism:modificationDate", content = "2013-10-04")
```

Metadata annotatuons in `NeXML` can be nested within another
annotation, which the `meta()` method accommodates by accepting a
parameter `children`, with the list of nested metadata objects (which
can themselves be nested) as value.

The `add_meta()` function adds metadata objects as annotations to a
`nexml` object at a specified level. The default level is the NeXML document as a whole:

```{r}
birds <- add_meta(modified, birds) 
```

If the prefix used by the metadata property is not among the built-in
ones (which can be obtained using the `get_namespaces()` as described
above), it has to be provided along with its URI as the `namespaces`
parameter. For example, the following uses the SKOS vocabulary (which
currently is not built-in) to add a note to the trees in the `nexml`
object:

```{r}
history <- meta(property = "skos:historyNote",
  content = "Mapped from the bird.orders data in the ape package using RNeXML")
birds <- add_meta(history, 
                birds, 
                level = "trees",
                namespaces = c(skos = "http://www.w3.org/2004/02/skos/core#"))
```

Alternatively, additional namespaces can also be added in batch using
the `add_namespaces()` method, which makes a list of namespaces known
to a given `nexml` object (or created a new `nexml` object, similar to
other `add_*` methods).

`RNeXML`, by virtue of subsetting the S4 `nexml` object, also offers
fine control of the level at which a `meta` element is added, for
which the package vignette contains examples.

Because NeXML expresses all metadata using the RDF standard, and
stores them compliant with RDFa, they can be extracted as an RDF graph
using off-the-shelf tools, and the RDF graph obtained in this way can
be queried in SPARQL (see @W3C_2014 or @Hartig_2012), the query
language for RDF graphs, using general purpose triple stores and
SPARQL query engines. The `RNeXML` vignette illustrates this with
examples, and the package also comes with a demonstration that can be
run from R using the following command: `demo("sparql", "RNeXML")`).

## Using metadata to extend the NeXML standard 

No data standard can anticipate all the uses and extensions
researchers may one day need. As the various "flavors" of the NEXUS
and other data formats show, this often results in extensions to
widely used exchange formats that almost invariably break
interoperability between such extensions and tools that were designed
to read one but not another. NeXML was designed to prevent this by
means of a highly flexible metadata system, while not sacrificing 
strict validation of syntax and structure.

Here we illustrate how NeXML's metadata system, and `RNeXML`'s API to
it, can be used to record and share a type of phylogenetic data not
taken into account when NeXML was designed. Specifically, we use the
example of stochastic character maps [@Huelsenbeck_2003], which assign
certain parts (corresponding to time) of each branch in a
time-calibrated phylogeny to a particular "state" (typically of a
morphological characteristic). The current de-facto format for sharing
stochastic character maps is a (non-interoperable) modification of the
standard Newick tree format created by a software tool widely used for
creating such maps, `simmap` [@Bollback_2006].

To express stochastic character map data as a custom metadata
extension, we create metadata annotations for the `edge` elements in
the phylogeny topology that relate parts of the annotated edge (branch)
to different states. These annotations need to describe the character state
being assigned, and the duration (in terms of branch length) that the edge 
spends in that state. The `NeXML` standard already defines `state`
elements for discrete character traits, which, as most elements in
NeXML, also have unique identifies (attribute `id`) by which they can
be referenced in other parts of the document. In the following
proposal, we call each series of character state assignments for an edge a
_reconstruction_, and for each state assignment comprising the
reconstruction, we provide the length, the identifier of the character
state, and an ordinal property to record the chronological order of
the state assignment (the identifier values in the proposal, "cr1",
"s1", and "s2", are -- fictitious -- identifiers that, in contrast to
global identifiers, are unique only within a given NeXML document):


```{r}
 m <- meta("simmap:reconstructions", children = c(
        meta("simmap:reconstruction", children = c(

          meta("simmap:char", "cr1"),
          meta("simmap:stateChange", children = c(
            meta("simmap:order", 1),
            meta("simmap:length", "0.2030"),
            meta("simmap:state", "s2"))),
          
          meta("simmap:char", "cr1"),
          meta("simmap:stateChange", children = c(
            meta("simmap:order", 2),
            meta("simmap:length", "0.0022"),
            meta("simmap:state", "s1")))
          ))))
```

The example uses a prefix, `simmap`, to group the newly introduced
metadata properties in a vocabulary, for which the `add_namespace()`
method can be used to give a URI as an identifier:

```{r}
nex <- add_namespaces(c(simmap = "https://github.com/ropensci/RNeXML/tree/master/inst/simmap.md"))
```

As we illustrate here, even if the URI does not resolve to a fully
machine-readable definition of the terms and their semantics, it can
still be used to provide at least a human-readable informal definition
of the terms, and where to find such documentation _is_
machine-readable in the resulting NeXML document. Aside from the fact
that the above representation does not modify the NeXML format, and
should thus be readable -- even if not necessarily interpretable as a
stochastic character mapping -- by any compliant NeXML parser, the
direct and machine-readable link to metadata documentation contrasts
with metadata or format extensions that are undocumented, or which do
not directly link to documentation.

Although writing out metadata annotations as in the above proposal may
seem tedious, by virtue of `RNeXML`'s API they can be expressed as a
series of R commands, and it is therefore straightforward to define
functions that encapsulate the details behind a parameter
signature. To demonstrate this, we implemented two functions in
`RNeXML`, `simmap_to_nexml()` and `nexml_to_simmap()`, that map
bidirectionally between NeXML files with `simmap` metadata according
to the above proposal, and the `simmap` data representation in R
devised by @Revell_2012 in the R package `phytools`. The latter uses
an extension of the `ape::phylo` class. As shown in more detail in the
`RNeXML` package vignette, this allows generating NeXML files
containing `simmap` data, reading those files into R, converting them
into the in-memory representation understood by `phytools`, and using
the various functions from `phytools` designed for `simmap` objects
[@Revell_2012], such as `plotSimmap()` for plotting.

## Publishing NeXML files from R

Data archiving is increasingly required by scientific journals,
including in evolutionary biology, ecology, and biodiversity
(e.g. @Rausher_2010). The effort involved with preparing and
submitting properly annotated data to archives remains a notable
barrier to the broad adoption of data archiving and sharing as a
normal part of the scholarly publication workflow
[@Tenopir_2011; @Stodden_2014]. In particular, the majority of
phylogenetic trees published in the scholarly record are inaccessible
or lost to the research community [@Drew_2013].

One of `RNeXML`'s aims is to promote the archival of well-documented
phylogenetic data in scientific data repositories, in the form of
NeXML files. To this end, the method `nexml_publish()` provides an API
directly from within R that allows data archival to become a step programmed
into data management scripts, rather than a separate manually executed
act. Initially, the method supports the data repository Figshare (http://figshare.com):

```{r eval = FALSE}
doi <- nexml_publish(birds, visibility = "public", repository="figshare")
```

Figshare also supports "private" visibility, allowing to securely backup
data to a repository and to share them with collaborators prior to public release.

# Future Directions

The goals for continued development of `RNeXML` revolve primarily
around three directions. One is better interoperability with other
existing phylogenetic data representations in R, such those found in
the `phylobase` package [@phylobase]. Another is better integration of
the rich metadata semantics found in ontologies defined in the Web
Ontology Language (OWL), including programmatic access to machine
reasoning with such metadata. Finally, and similar to many other R
packages, including those for comparative phylogenetics, in light of
the increasing size of phylogenomic and other datasets mechanisms may
eventually be needed that avoid the requirement to load an entire
file's content into memory.

## Acknowledgements

This project was supported in part by the National Evolutionary
Synthesis Center (NESCent) (NSF #EF-0905606), and grants from the
Natioal Science Foundation (DBI-1306697) and the Alfred P Sloan
Foundation (Grant 2013-6-22). `RNeXML` started as a project idea for
the Google Summer of Code, and we thank Kseniia Shumelchyk for taking
the first steps to implement it. We are grateful to F. Michonneau for
helpful comments on an earlier version of this manuscript.



```{r cleanup, include=FALSE, cache=FALSE}
unlink("simmap.xml")
unlink("birds.xml")
unlink("geospiza.xml")
unlink("rdf_meta.xml")
```


<!-- Footnotes -->

[^1]: By providing the optional `dependencies` argument, R will install
additional packages used in some of the advanced examples shown later
but which are not required for basic functionality.

[^2]: For convenience `nexml_read` is also aliased as `read.nexml`,
for users familiar with the somewhat analogous `read.nexus` function.
