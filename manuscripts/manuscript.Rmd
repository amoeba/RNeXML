---
#layout: preprint
layout: review, 11pt
title: "RNeXML: a package for reading and writing richly annotated phylogenetic, character, and trait data in R"
author: 
  - name: Carl Boettiger
    affiliation: cstar
    email: cboettig(at)gmail.com
    footnote: Corresponding author
  - name: Hilmar Lapp
    affiliation: NESCent
  - name: Scott Chamberlain
    affiliation: ropensci
  - name: Rutger Vos
    affiliation: NBC
address: 
  - code: cstar
    address: | 
      Center for Stock Assessment Research, 
      Department of Applied Math and Statistics, 
      University of California, Mail Stop SOE-2,
      Santa Cruz, CA 95064, USA
  - code: NESCent
    address: | 
      National Evolutionary Synthesis Center, Durham, NC, USA
  - code: ropensci
    address: |
      University of California, Berkeley, CA, USA
  - code: NBC
    address: | 
      Naturalis Biodiversity Center, Leiden, the Netherlands
abstract: | 
      1. NeXML is a new exchange format for phylogenetic data and
      metadata that offers substantial improvements in reliability,
      extensibility, and richness over earlier formats such as
      NEXUS. In this paper we present the RNeXML package which
      provides a bridge between this data format and the extensive
      library of phylogenetic tools already available in the popular
      data analysis environment and programming language R, with a
      particular emphasis on comparative methods.

      2. The ability to parse and write NeXML from within R is only a
      small part of the functionality offered by the package.  We
      illustrate how RNeXML facilitates adding and manipulating data
      annotations whose meaning can be defined in a precise and
      machine-interpretable way by means of formal ontologies and other
      semantic web technologies.

      3. An essential feature of NeXML is to provide both the
      flexibility to be continually extended to meet the emerging
      needs of the phylogenetics community without breaking software
      unaware of such extensions. We illustrate how RNeXML makes
      it easy to extend NeXML in this manner.
      
      4. RNeXML is well suited for users to preserve and maintain
      their personal archives of phylogenetic and comparative trait
      data in consistent, query-able, and cross-platform format, to
      leverage the rapidly growing public community archives of rich
      NeXML files, and to interact with web services that return data
      and their metadata packaged together as NeXML.

bibliography: components/references.bib
csl: components/methods-in-ecology-and-evolution.csl
documentclass: components/elsarticle

output: 
  pdf_document:
    template: components/elsarticle.latex
    keep_tex: true
    fig_caption: true


---

<!------------------------------------------------

Map/Outline:
------------

- Introduction
  - Exciting times in phylogenetics!  
  - Challenges with existing formats 
  - Overview of NeXML
  - Challenges with R
  - Map 

- Tutorial
  - Reading Phylogenetic trees
  - Reading Character data
  - Writing phylogenetic trees & character data

  - Metadata
    - Adding basic metadata
    - Adding taxonomic identifiers
    - Adding Generic metadata
    - Parsing metadata. XML. RDF.
    - Extending NeXML with metadata: Example defining simmap stochastic character mappings.  

  - Publishing NeXML 

- Implementation, Quality Control
- Software reuse and support

------------------------------------------------>





```{r compile-settings, include=FALSE}
library("methods")
library("knitr")
opts_chunk$set(tidy = FALSE, warning = FALSE, message = FALSE, 
               cache = 1, comment = NA, verbose = TRUE)
basename <- gsub(".Rmd", "", knitr:::knit_concord$get('infile')) 
opts_chunk$set(fig.path = paste("components/figure/", basename, "-", sep=""),
               cache.path = paste("components/cache/", basename, "/", sep=""))


```

# Introduction

The popular statistical and mathematical computing platform R [@R] arguably provides the most extensive and widely used collection of
comparative phylogenetic methods tools <!-- needs a citation to support it -->.
Yet, R users lack a convenient and extensible way to import, exchange and archive 
phylogenetic data, trait data, and their accompanying rich metadata in
a data exchange standard that comprehensively supports current data
exchange needs, is predictably machine-readable, and is forward compatible.
In response to the rapid increase in the variety of data
relevant to comparative analysis, and the rising data interoperability
needs of integrative comparative research approaches, such an exhcange standard,
called NeXML, has recently
been developed [@Vos_2012], and is beginning to be adopted. One of the
hurdles to broader adoption of any exchange standard is the
availability of easy-to-use programmtic interfaces (APIs) to the
format, in particular for developers of tools that consume or generate
relevant data, so that supporting the standard for reading input and
writing output data does not require additional effort, compared to,
say, using other but inferior exchange formats. Here we present such
an API in the form of an R package, called RNeXML. RNeXML aims to
provide easy programmatic access to reading and writing NeXML documents,
tailored for the kinds of use-cases that will be common for users and
developers of the wealth of evolutionary, and in particular
comparative analysis methods within the R ecosystem.

Increasingly many comparative research questions have come to exploit
the opportunities from, and thus rely on the ability to reuse and
integrate previously generated or published data and
metadata. However, the ever expanding needs of the evolutionary
research community are rapidly outpacing the capabilities of the
currently still most widely used exchange standards, which were all
developed a decade or more ago. This has resulted in a radiation of
different data representations and exchange standard "flavors" that
are no longer interoperable at the very time when the growth of
available data and methods has made that interoperability most
valuable. The problem is particularly acute in light of the challenges
for finding and sharing phylogenetic data
[@Drew_2013; @Stoltzfus_2012], in particular in a way that is not
subject to loss of most data and metadata semantics, or that is
amenable to predictable machine interpretation [@Cranston_2014]. For
example, the currently popular NEXUS file format [@Maddison_1997] cannot consistently
represent horizontal gene transfer or ambiguity in reading a character
(such as a DNA sequence base pair).  This has led to
modifications of NEXUS in different ways for different needs, with the unfortunate
result that NEXUS files generated by one program can be incompatible
with another [@Vos_2012]. Without a formal grammar, software based on 
NEXUS files may also make inconsistent assumptions about tokens, quoting,
or element lengths.  @Vos_2012 estimates that as many as 15% of the NEXUS
files in the CIPRES portal contain unrecoverable but hard to diagnose errors.

A detailed account of how the NeXML standard addresses these and other
relevant challenges can be found in @Vos_2012. In brief, NeXML was
designed with the following important properties. First, NeXML is defined
by a precise grammar that can be programmatically **validated**. This
ensures that any NeXML file can be expected to be parsed and read
without errors by any NeXML-compliant software, provided the file
passes validation. Second, NeXML is **extensible**: a user can define
representations of new, previously unanticipated information (as we
will illustrate) without violating its defining grammar. Third and
most importantly, NeXML is **semantically rich**.
The use of formal semantics in NeXML makes its data representation
not only machine-readable in a predictable manner, but also enables machine reasoning about
the data and metadata (see @Parr2011 for an overview on semantic reasoning in 
evolutionary informatics). Instead of asking the computer to
return "the data on line #93" <!-- this is a pretty obscure example, -->
<!-- and I'm not even clear what you mean here, so having a hard time -->
<!-- coming up with an improvement -->, we can expect the computer to reason about
taxonomic concepts (as we illustrate in the supplement). 

The R language and platform [@R] has become a powerful ecosystem for
evolutionary analysis, with over 30 packages available alone for
comparative phylogenetics, several of which have accumulated over 
1000 citations [@taskview]. `RNeXML` makes the sizable amount of
richly annotated phylogenetic data already existing in NeXML format
available to R users and R's ecosystem, in a way, as we show here,
that is no more involved than reading or writing data from other
phylogenetic data formats. `RNeXML` also carries immediate benefits
for its users. For example, comparative analysis R packages and users
frequently add their own metadata annotations to the phylogenies they work with, including annotations of species,
stochastic character maps, trait values, model estimates and parameter 
values. `RNeXML` affords R the capability to harness machine-readable
semantics and an extensible metadata schema to capture, preserve, and
share these and other kinds of information, all through an API instead
of having to understand in detail the schema underlying the NeXML
standard. To assist users in meeting the rising bar for best practices
in data sharing in phylogenetic research [@Cranston_2014], `RNeXML`
captures metadata information from the R environment to the extent
possible, and applies reasonable defaults. Beyond these more immediate
benefits, `RNeXML` plugs the R ecosystem into the growing informatics
infrastructure of evolutionary informatics [@Parr2011], in which
interoperable data and machine-readable semantics play important
enabling roles. 

The rest of this paper is organized as follows. First, we introduce
the basic use and concepts of RNeXML for reading and writing
phylogenetic trees and character trait data from and to NeXML. We then
focus on RNeXML's support for reading and writing the kind of
semantically rich metadata that most sets NeXML apart from
other phylogenetic data formats. We include examples of
increasing complexity to illustrate concepts and tools from biodiversity
informatics that allow users to express and interpret complicated data
structures automatically.  We end this section with a concrete example illustrating
how RNeXML facilitates harnessing the forward-compatibility property
of NeXML, by devising a serialization for stochastic character
mappings, a data annotation generated by existing R packages but
lacking a standard exchange format. Next we illustrate how RNeXML
promotes data archiving and sharing by providing commands for directly
publishing NeXML files to a data repository. We conclude the paper
with a brief description of how the software has been
implemented, what quality control measures are in place, as well as
information about software reuse and getting support.

This paper has been written as a dynamic document in R Markddown
[@Xie_2013], which directly exercises all of the code blocks shown every time
the typeset version is regenerated, providing immediate feedback on
whether the code as shown is complete and continues to work. It also
means that the reader may paste the code blocks into their own R
terminal to follow along with the examples.


# Introduction to RNeXML

Conceptually, a NeXML document has the following components: (1) phylogeny
data, (2) character or trait data in matrix form, (3) operational
taxonomic units (OTUs), and (4) metadata. When reading and writing NeXML,
`RNeXML` aims to map these to and from, respectively, their most
natural representations in R. These are the `phylo` object from the
`ape` package [@Paradis_2004], R's native `data.frame` list structure for
phylogenies, character matrices, and metadata, respectively.
<!-- compared to the preceding enumeration, this is missing where the OTUs go -->

NeXML allows attaching metadata to any data element, and even to
metadata themselves. At the level of the document as a whole or the
phylogeny, metadata can provide bibliographic and provenance
information, for example about the study as part of which the
phylogeny was generated or applied, and with which methods it was
generated. In the form of annotations, metadata can also be attached
to very specific elements of the data, such as individual OTUs, nodes,
or even edges of the phylogeny.

## Getting Started

The current stable version of the `RNeXML` package can be installed from
the CRAN library[^1].  

```r
install.packages("RNeXML", dependencies=TRUE)
```


## Reading phylogenetic trees



```{r echo=FALSE}
library(RNeXML)
```

We begin by loading the `RNeXML` package and reading in an example
NeXML file provided with the package, containing two small phylogenetic
trees.[^2]

```{r}
library("RNeXML")
nex <- nexml_read("components/trees.xml")
```
The resulting `nex` object is of type `nexml` and is a native R object representation of the NeXML
file. 
Objects of type `nexml` represent phylogenetic trees as well as 
character traits, and semantic metadata. As such, this new R object format differs
from existing formats such as `ape::phylo` format [@Paradis2004],
which describes trees alone, or any of the `phylobase` classes of object that contain 
trees and traits but more limited metadata [@phylobase]. 

Although new custom R functions and packages 
could be written for using `nexml` objects, for most users it will be
more convienent to use methods of the many already existing R packages for 
phylogenetics. From a `nexml` object, we can 
therefore extract any phylogenies it contains in the `ape::phylo` format. In this 
case we will get back a `multiPhylo` object, since the file contains two phylogenies.

```{r}
phy <- get_trees(nex)
```

We can then leverage the rich suite of methods available from the R
phylogenetics community. For instance, here we use the standard plotting function from
the `ape` package to plot the first tree in the resulting `ape::phylo` object returned by
`get_trees`.

```{r eval=FALSE}
plot(phy[[1]])
```

Note that NeXML can not only contain multiple phylogenetic trees in a single document,
but can also group sets of trees into separate blocks (e.g. as resulting from
different workflows). The `get_trees()` function is designed for interactive use, and thus attempts to return the most sensible R object for NeXML: if only a single tree is available, it will return an `ape::phylo` 
object; if multiple trees are available in a single `trees` block, it will return
an `ape::multiPhylo` object (a list of `ape::phylo` objects).  If multiple
blocks are available, it will return a list of `multiPhylo` blocks.

For scripted use, it is desirable to have a consistent return type.  To always get back a list of `multiPhylo` objects,
even when only one tree is available, use `get_trees_list()`.

The ability to read in phylogenetic trees in the NeXML format opens up a
wide and rapidly growing array of resources to the R user.  For instance,
a user can access all the phylogenies available in 
[TreeBASE](http://treebase.org/) 
 through the
`nexml` format.  `RNeXML`'s `nexml_read` can also read a file directly from a URL by automatically recognizing the URL patterns and first downloading the file to a working directory:

```{r eval=FALSE}
nex <- nexml_read("https://raw.github.com/rvosa/supertreebase/master/data/treebase/S100.xml")
```


## Reading character data 

Like NEXUS files, NeXML documents can in addition to trees also
contain character data in the form of matrices.  Character data can be
of molecular (molecular sequence alignments), discrete (most
morphological character data), or continuous type (many trait data). 
Often character data, especially molecular and morphological, is used
for phylogenetic tree reconstruction, but they are also a common input
for the many comparative phylogenetic analysis methods available in R. Methods to extract character data
work much like those for extracting the phylogenetic trees. Here we read in an example
NeXML file that contains both a phylogeny and character data. The
function
`get_characters()` can then be used to obtain a `data.frame` with columns as characters and rows as
taxa:

```{r }
nex <- nexml_read("components/comp_analysis.xml")
get_characters(nex)
```
Continuous and discrete character data are represented as separate
blocks in NeXML files, but will be combined as separate columns of a
single data frame by `get_characters()` if they correspond to the same
taxa. If this behavior is undesired, the function
`get_characters_list()` can be used to obtain
a list of data frames, where list elements correspond to the character matrix blocks of
the NeXML file.


## Writing phylogenetic trees 

Generating NeXML files from R is likewise straightforward.  Here we
write a phylogeny from the `ape::phylo` format out to a NeXML file:

```{r}
data(bird.orders)
nexml_write(bird.orders, file = "birds.xml")
```

The first argument to `nexml_write()` is a `nexml` object, or any
object that can be coerced to it, such as a `ape::phylo` phylogeny,
or a `multiPhylo` list of phylogenies. The `nexml_write()` function
also allows to add character data:

```{r}
library("geiger")
data(geospiza)
nexml_write(trees = geospiza$phy, characters = geospiza$dat, file="geospiza.xml")
```

These examples use data from the popular phylogenetics software `geiger` [@Harmon_2008].
Instead of packaging trees and characters at the time of writing a
NeXML file, the document can also be built up step by step using the
functions `add_characters()`,
`add_trees()`, and `add_meta()`.  Each of these functions can add data to an
existing `nexml` object, or create a new nexml object if none is provided.
Here we first create a `nexml` object containing the phylogeny data,
and then add the character data to it:

```{r}
geiger_nex <- add_trees(geospiza$phy)
geiger_nex <- add_characters(geospiza$dat, geiger_nex)
```

The data need not share the same taxa.  We can append additional
phylogenies and characters corresponding to different taxa:

```{r}
data(primates)
geiger_nex <- add_trees(primates$phy, geiger_nex)
geiger_nex <- add_characters(primates$dat, geiger_nex)
```

This allows us to include multiple trees and character matrices to a
single NeXML file, for instance, to represent samples from posterior
probability distributions of inferred or simulated phylogenies or
character states.

# Metadata

At the heart of the NeXML standard is the ability to encode arbitrary
metadata in precisely specified, machine-readable formats that maintain
backwards compatibility with any existing NeXML parser. NeXML uses the
"Resource Description Framework in Annotations" (RDFa),
as described in @Vos_2012 or @W3C_2014. 
These annotations can be used to add 
information to any particular element of the data, (a tree, node, edge,
or taxonomic unit; a character matrix or specific trait, or even another 
metadata annotation or the NeXML data file as a whole). `RNeXML` provides
a range of tools for accessing metadata embedded in a NeXML file. 



## Writing NeXML metadata

The burden typically involved with documenting and sharing good
metadata alongside the data remains a
significant barrier to increased sharing and reuse of scientific research
[@Tenopir_2011]. To promote sharing of well-documented phylogenetic data,
`RNeXML` aims to provide a simple interface to adding well-defined machine-readable metadata to NeXML files. This occurs on
several levels:

- Automatic annotation
- Adding common metadata fields (`add_basic_metadata`)
- Taxonomic identifiers (`taxize_nexml`)
- Generic metadata (`add_meta`)
- Extending the NeXML standard using RDFa

`RNeXML`'s `nexml_write` function adds certain basic metadata by automatically
if it has not yet been provided; using default values
consistent with recommended best practices [@Cranston_2014]. At this time,
this includes naming the software generating the NeXML, a time-stamp of
when a tree was produced, and an open data license.

To adjust these values and also add other metadata fields commonly recommended for
includion with publicly archived data, `RNeXML` provides the `add_basic_meta()`
function.  This function hides the complexities of anchoring metadata
attribute names in common vocabularies from the user.  The
`add_basic_meta()` function takes as input an existing `nexml` object
(like the other `add_` functions, if none is provided it will create one), and at the time
of this writing any of the following
parameters: `title`, `description`, `creator`, `pubdate`, `rights`, `publisher`,
`citation`.  Other metadata elements and corresponding parameters may
be added in the future.

Here we create a `nexml` object for the `bird.orders` data
provided in the `ape` package, and then add basic metadata:

```{r}
data(bird.orders)
birds <- add_trees(bird.orders)
birds <- add_basic_meta(
  title = "Phylogeny of the Orders of Birds From Sibley and Ahlquist",

  description = "This data set describes the phylogenetic relationships of the
     orders of birds as reported by Sibley and Ahlquist (1990). Sibley
     and Ahlquist inferred this phylogeny from an extensive number of
     DNA/DNA hybridization experiments. The ``tapestry'' reported by
     these two authors (more than 1000 species out of the ca. 9000
     extant bird species) generated a lot of debates.

     The present tree is based on the relationships among orders. The
     branch lengths were calculated from the values of Delta T50H as
     found in Sibley and Ahlquist (1990, fig. 353).",

  citation = "Sibley, C. G. and Ahlquist, J. E. (1990) Phylogeny and
     classification of birds: a study in molecular evolution. New
     Haven: Yale University Press.",

  creator = "Sibley, C. G. and Ahlquist, J. E.",
  nexml = birds)
```
<!-- the above will get fixed by CB, this is just a reminder and -->
<!-- placeholder to adjust when that's done. -->

Instead of a literal string, citations can also be provided in R's
`bibentry` type, which is the one in which R package citations are obtained:

```{r}
birds <- add_basic_meta(citation = citation("ape"), nexml=birds)
```

Alternatively, a citation to a published paper with a Digital
Object Identifier (DOI) can be provided in the form of the DOI,
which the package `knitcitations` [@Boettiger_2014] can turn into a
formatted citation using. As an example, to add the citation information of the paper that generated the
`geospiza` phylogeny included in the `geiger` package: 

```{r}
library("knitcitations")
geiger_nex <- add_basic_meta(citation = bib_metadata("10.2307/2408428"), nexml=geiger_nex)
```



## Taxonomic identifiers

`RNeXML` provides various functions to assist in automatically adding
other more specific metadata to various elements of the NeXML data.
One common use case is that of taxonomic identifiers.  Misspellings or
inconsistent use of taxonomic names in phylogenetic data are a common
source of frustration when reusing phylogenetic trees, especially when
integrating data from different sources: trees might come from one place
that uses one taxonomy, character data and occurrence data might come from
other places that use different taxonomies. Hence, not just misspellings,
but also synonyms, homonyms and incompatible taxon concepts might plague
the end user. By associating the taxonomic labels against a specific,
centralized database we can catch some of these inconsistencies and
indicate more precisely which classification we are appealing to in the
event of conflicting taxonomic definitions.  In this example, we indicate
that we intend the bird orders listed in the tree to correspond to the
NCBI definitions.

The `taxize_nexml()` function uses the R package `taxize` 
[@Chamberlain_2013] to check each taxon label against the NCBI database.
If a unique match is found, a metadata annotation is added to the taxon
providing the NCBI identification number to the taxonomic unit.


```{r message=FALSE, results='hide'}
birds <- taxize_nexml(birds, "NCBI")
```
If no match is found, the user is warned to check for possible typographic
errors in the taxonomic labels provided. If multiple matches are found,
the user will be prompted to choose between them.


## Custom metadata extensions

So far our examples have relied on functions that have a built-in
understanding of the kind of metadata being provided, and can thus
generate the appropriate metadata with little further guidance.
In order to be machine-readable and understandable, NeXML requires
all metadata annotations follow the RDFa format (see @Vos_2012) which
explicitly declares the meaning of the annotation. 

Some basic definitions about the XML syntax used to express NeXML
will be helpful for this discussion, though a more comprehensive 
introduction can be found in @Vos_2012.  For instance, consider how
the title we gave to the `bird.orders` phylogeny appears in the NeXML file
using the XML format:

```xml
<meta id="m2" property="dc:title" datatype="xsd:string"
      content="Phylogeny of the Orders of Birds From Sibley and Ahlquist"/> 
```

The format begins with an XML "tag" and the name "meta", indicated by the opening
angle bracket; `<meta`.  A closing tag `\>` indicates the end of this
XML "element" .  This tag contains several "attributes", named "id",
"property", etc., that an R user can think of as names in a `list`. What
follows the equals sign after the attribute name is called the attribute "value",
(e.g. the `id` attribute has value "m2").  

The name of any element (like "meta") or attribute (like "id") in XML must be associated
with a particular dictionary called a "namespace" and specified using a "prefix"
of an abbreviation followed by a colon appearing before the name.  If no prefix
is given, as is the case for all attributes here: `id`, `property`, `datatype`,
and `content`, then a default prefix specified at the beginning of the document applies,
in this case, the NeXML namespace.  This allows users to combine different XML
that have different definitions of terms like `id` or `property`.  

The example element above also uses namespaces on some of the attribute values themselves.
This is a consequence of RDFa annotation, and not strictly part of XML, though
it works much the same way.  While we hope the following examples will make these
concepts clearer, users do not need to understand XML and namespaces to use most
of the basic annotation features provided by `RNeXML`.   

So much for the structure; we can now briefly explain the meaning of this element. 
We see the title appears as the value of the `content` attribute of this `meta` element.
The `id` attribute provides us with a unique way to refer to this meta
element in this document.  The `datatype` tells us that the content
is a text string (as opposed to, say, a numerical or boolean value).
The `property` is the attribute that most interests us here; it tells us
that the content is a title.  The prefix `dc` indicates the vocabulary
(here identified as an XML namespace) to which the word `title` belongs.  The prefix
is defined elsewhere in the NeXML file, as we can see with:


```{r}
prefixes <- get_namespaces(birds)
prefixes["dc"]
```

This URL links us to a web page providing both a human and machine-readable
version of precisely what the term `title` means, showing us that it
refers to `title` in the sense of a creative work, rather than the title
of a person, a legal title, the verb title, etc.  This precision can allow
us to perform precise computer reasoning on metadata, without relying on
heuristics or assumptions, as we illustrate later.  For the moment though,
the need to refer to an explicit controlled vocabulary (or ontology)
with a url, saying "dc:title" rather than just saying the property is
"title", is something of a burden in creating metadata.  The previous
examples involve functions that already know what kind of metadata is
being provided (a title, a data creator, etc), and so can provide the
appropriate vocabulary automatically.  The main advantage of linking to
an external vocabulary, however, is the ability to express concepts that
are not already "built in" to the data model.  `RNeXML` provides tools
to generate arbitrary metadata annotations given an external vocabulary,
such as we illustrate here.


From the list of namespaces in `prefixes`, we can follow links to a handful
of established vocabularies and find terms that are not included in
`add_basic_meta()`.  For instance, by resolving the location identified
by the `prism` prefix,

```{r}
prefixes["prism"]
```

we will find that there is a term for `modificationDate` for a file.  We create
a `meta` element containing this annotation using the `meta` function:

```{r}
modified <- meta(property = "prism:modificationDate", content = "2013-10-04")
```

We can add this annotation to our existing `birds` NeXML file using the
`add_meta()` function.  Because we do not specify a level, it is added to
the root node, referring to the NeXML file as a whole.

```{r}
birds <- add_meta(modified, birds) 
```

The built-in vocabularies are just the tip of the iceberg of established
vocabularies. Here we add an annotation from the `skos` namespace which
describes the history of where the data comes from:

```{r}
history <- meta(property = "skos:historyNote",
  content = "Mapped from the bird.orders data in the ape package using RNeXML")
```

Because `skos` is not in the current namespace list, we add it with a
url when adding this meta element.  We also specify that this annotation
be placed at the level of the `trees` sub-node in the NeXML file.

```{r}
birds <- add_meta(history, 
                birds, 
                level = "trees",
                namespaces = c(skos = "http://www.w3.org/2004/02/skos/core#"))
```


For finer control of the level at which a `meta` element is added,
we will manipulate the `nexml` R object directly using S4 sub-setting,
as shown in the supplement.


Much richer metadata annotation is possible. Later we illustrate how
metadata annotation can be used to extend the base NeXML format to
represent new forms of data while maintaining compatibility with any
NeXML parser. The `RNeXML` package can be easily extended to support
helper functions such as `taxize_nexml` to add additional metadata
without imposing a large burden on the user.


## Reading NeXML metadata

A call to the `nexml` object prints some metadata summarizing the data structure: 

```{r }
birds
```

We can extract all metadata pertaining to the NeXML document as a whole
(annotations of the XML root node, `<nexml>`) with the command

```{r}
meta <- get_metadata(birds) 
```

This returns a named list of available metadata. We can see the kinds
of metadata recorded from the names (showing the first 4):

```{r}
names(meta)[1:4]
```

and can ask for a particular element using the standard list sub-setting
mechanism (i.e. either the name of an element or its numeric position),

```{r}
meta[["dc:title"]]
```

All metadata terms must belong to an explicit *namespace* or vocabulary
that allows a computer to interpret the term precisely. The prefix (before
the `:`) indicates to which vocabulary the term belongs, e.g. `dc` in
this case.  The `get_namespaces` function tells us the definition of
the vocabulary using a link:

```{r}
prefixes <- get_namespaces(birds)
prefixes["dc"]
```


<!-- the citations run off the page -->
Common metadata can be accessed with a few dedicated functions:

```{r get_citation}
get_citation(birds)
```


```{r get_taxa}
get_taxa(birds)
```

Which returns text from the otu element labels, typically used to define
taxonomic names, rather than text from explicit meta elements.



We can also access metadata at a specific level (or use `level=all`
to extract all meta elements in a list).  Here we show only the first
few results:

```{r} 
otu_meta <- get_metadata(birds, level="otu")
otu_meta[1:4]
```

This approach does not preserve the relationship between the metadata element and the 
`otu` it was annotating, and as such is most useful for quick visual exploration. 
Metadata values for specific elements or sets of elements can always be accessed using
the S4 sub-setting mechanisms (see section below).  



## RDF manipulation and SPARQL queries 

The most powerful way to take advantage of the machine-readable nature
of the metadata involves the construction of SPARQL queries. This
approach can exploit the reasoning and logical deduction capacity of
formal vocabularies (ontologies). For a proper introduction to SPARQL
queries, see @W3C_2014 or @Hartig_2012).  

The real expressiveness of SPARQL is better illustrated through more
complex examples such as the one shown in the supplementary materials
(which can also be run from R using the command: `demo("sparql", "RNeXML")`).
This demonstration constructs a cladogram based on the taxonomic ranks
provided in the NeXML. SPARQL allows us to make explicit use of ontological
concepts such as manipulating sub-classes (i.e. that "Genus" is a subclass 
of "Family"), or joining multiple predicates (i.e. retrieve the NCBI identifier
of the OTU that has taxon rank of "Order").  


## Extending the NeXML standard through metadata annotation.

No data standard can anticipate all the uses and extensions researchers
may one day need. Researchers have repeatedly adapted the existing NEXUS
file format to accommodate encoding new kinds of information, but in the
process break compatibility between different flavors of NEXUS files, with
few reliable methods to distinguish between these flavors.  NeXML provides
a solution to this problem through the use of metadata annotation.

Here we illustrate this process using the example of stochastic character
mapping [@Huelsenbeck_2003]. A stochastic character map is simply
an annotation of the branches on a phylogeny, assigning each section
of each branch to a particular "state" (typically of a morphological
characteristic).

@Bollback_2006 provides a widely used stand-alone software implementation
of this method in the software `simmap`, which modified the standard
Newick tree format to express this additional information. This can
break compatibility with other software [^3], and creates a format that
cannot be interpreted without additional information describing this
convention.  By contrast, the NeXML extension is not only backwards
compatible but contains a precise and machine-readable description of
what it is encoding.

In this example, we illustrate how the additional information required
to define a stochastic character mapping (a `simmap` mapping) in NeXML.  

@Revell_2012 describes the `phytools` package for R, which includes
utilities for reading, manipulating, and writing `simmap` files in R.
In this example, we also show how to define `RNeXML` functions that 
map the R representation used by Revell (an extension of the `ape` class)
into the NeXML extension we have defined by using `RNeXML` functions.

Since a stochastic character map simply assigns different states to
parts of a branch (or edge) on the phylogenetic tree, we can create
a NeXML representation by annotating the `edge` elements with appropriate
`meta` elements.  These elements need to describe the character state
being assigned and the duration (in terms of branch-length) that the edge 
spends in that state (Stochastic character maps are specific to time-calibrated
or ultrametric trees).  

NeXML already defines the `characters` element to handle discrete character traits (`nex:char`)
and the states they can assume (`nex:state`).  We will thus reuse the `characters` element for
this purpose, referring to both the character trait and the states by the ids assigned to them
in that element.  (NeXML's convention of referring to everything by id permits a single canonical
definition of each term, making it clear where additional annotation belongs).  For each edge, we 
need to indicate:

<!-- Ugh, do we need to explain that everything in NeXML uses an id so that it can be reused in this way?
     -->

- That our annotation contains a stochastic character mapping reconstruction
- Since many reconstructions are possible for a single edge, we give each reconstruction an id
- We indicate for which character trait we are defining the reconstruction 
- We then indicate which states the character assumes on that edge. 
  For each state realized on the edge, that involves stating: 
    + the state assignment
    + the duration (length of time) for which the edge spends in the given state
    + the order in which the state changes happen (Though we could just assume 
      state transitions are listed chronologically, NeXML suggests making all 
      data explicit, rather than relying on the structure of the data file to
      convey information).  

Thus the annotation for an edge that switches from state `s2` to state 
`s1` of character `cr1` would be constructed like this:

```{r}
 m <- meta("simmap:reconstructions", children = c(
        meta("simmap:reconstruction", children = c(

          meta("simmap:char", "cr1"),
          meta("simmap:stateChange", children = c(
            meta("simmap:order", 1),
            meta("simmap:length", "0.2030"),
            meta("simmap:state", "s2"))),
          
          meta("simmap:char", "cr1"),
          meta("simmap:stateChange", children = c(
            meta("simmap:order", 2),
            meta("simmap:length", "0.0022"),
            meta("simmap:state", "s1")))
          ))))
```

Of course writing out such a definition manually becomes tedious quickly. Because
these are just R commands, we can easily define a function that can loop over an
assignment like this for each edge, extracting the appropriate order, length and
state from an existing R object such as that provided in the `phytools` package.  
Likewise, it is straightforward to define a function that reads this data using
the `RNeXML` utilities and converts it back to the `phytools` package. The full
implementation of this mapping can be seen in the `simmap_to_nexml()` and the
`nexml_to_simmap()` functions provided in the `RNeXML` package.  

As the code indicates, the key step is simply to define the data in meta elements. In 
so doing, we have defined a custom namespace, `simmap`, to hold our variables.  This
allows us to provide a URL with more detailed descriptions of what each of these 
elements mean:

```{r}
nex <- add_namespaces(c(simmap = "https://github.com/ropensci/RNeXML/tree/master/inst/simmap.md"))
```

At that URL we have posted a simple description of each term. 

Using this convention we can generate NeXML files containing `simmap`
data, read those files into R, and convert them back into the `phytools`
package format. These simple functions serve as further illustration of
how `RNeXML` can be used to extend the NeXML standard.  We illustrate
their use briefly here, starting with  loading a `nexml` object containing
a `simmap` reconstruction into R:


```{r}
data(simmap_ex)
```

The `get_trees()` function can be used to return an `ape::phylo` tree as
usual.  `RNeXML` automatically detects the `simmap` reconstruction data
and returns includes this in a `maps` element of the `ape::phylo` object,
for use with other `phytools` functions.

```{r}
phy <- nexml_to_simmap(simmap_ex)
```

We can then use various functions from `phytools` designed for `simmap`
objects [@Revell_2012], such as the plotting function:

```{r Figure1, fig.cap="Stochastic character mapping on a phylogeny, as generated by the phytools package after parsing the simmap-extended NeXML."}
library("phytools")
plotSimmap(phy)
```

Likewise, we can convert the object back in the NeXML format and write
it out to file to be read by other users. 

```{r}
nex <- simmap_to_nexml(phy) 
nexml_write(nex, "simmap.xml")
```

Though other NeXML parsers (for instance, for Perl or Python) have
not been written explicitly to express `simmap` data, those parsers will
nonetheless be able to successfully parse this file and expose the `simmap`
data to the user.





## Publishing NeXML files from R

Data archiving is increasingly required by journals in evolutionary biology and 
biodiversity (e.g. @Rausher_2010).  The burden of preparing and submitting properly
annotated data to archives continues to be a significant barrier [@Tenopir_2011; @Stodden_2014],
and many phylogenetic trees upon which studies are based are inaccessible or lost 
to the research community [@Drew_2013].  `RNeXML` seeks to lower these barriers
by providing functions to immediately archive NeXML files in scientific repositories.  




```{r eval = FALSE}
doi <- nexml_publish(birds, visibility = "public", repository="figshare")
```

Robust data archiving need not involve immediate release of the data. The `figshare` 
repository supports the option of `visibility = "private"`, allowing secure 
publication that provides a way to backup and share data with collaborators 
prior to public release.  


# Software reuse and support

The `RNeXML` package is available through the CRAN repository under
a CC0 license. At the time of writing, the current version is `r packageDescription("RNeXML", fields="Version")`. 
The current development
branch can be found on Github at [https://github.com/ropensci/RNeXML]().
See the NEWS file for changes in recent versions. Users are encouraged
to submit bug reports or feature requests in the issues log.  Contact
`ropensci-discuss@googlegroups.com` or the package maintainer for help,
or email the phylogenetics R users group list at `r-sig-phylo@r-project.org`.  


There are many promising directions for further development of the
`RNeXML` package.  The project's [Milestones page](https://github.com/ropensci/RNeXML/issues/milestones) page provides a list of
steps currently planned or under consideration.  In particular, these
milestones include increased support for interactive mode of entering data
(wizards), conversions to and from other existing R phylogenetics formats
such those found in the `phylobase` package [@phylobase],
and support for integration of semantics defined through the
Web Ontology language (OWL), as discussed in the Challenges section.

## Future Directions

For convenience, the RNeXML package can parse compressed XML binaries (gzipped XML) directly, facilitating work with very large data files.  As most R functions, especially those in common phylogenetics packages, require in-memory data structures, RNeXML currently loads this data directly into memory. Future work could facilitate manipulation of NeXML data directly from the disk.

Emerging formats such as the JSON based NeXSON format provide alternate representations of semantic, machine-readable phylogenetic data. At this time, R users must still rely on other tools that can convert these formats into NeXML.
Because the NeXML syntax is extensible, semantic, and machine-readable, this can be done without loss, unlike NEXUS formats.  Nevertheless, a possible future direction would be to provide direct support of such formats through RNeXML or a companion R package.

## Acknowledgements
<!-- FIXME Rutger, Hilmar, add whatever you'd like to acknowledge here -->. 

This project was supported in part by a grant from the Alfred P Sloan
Foundation Grant 2013-6-22 (CB and SC), NSF Grant DBI-1306697 (CB), ... 
We thank F. Michonneau for helpful comments on an earlier version
of this manuscript.
`RNeXML` is part of the rOpenSci project, [http://ropensci.org].



```{r cleanup, include=FALSE, cache=FALSE}
unlink("simmap.xml")
unlink("birds.xml")
unlink("geospiza.xml")
unlink("rdf_meta.xml")
```


<!-- Footnotes -->

[^1]: By providing the optional `dependencies` argument, R will install
additional packages used in some of the advanced examples shown later
but which are not required for basic functionality.

[^2]: For convenience `nexml_read` is also aliased as `read.nexml`,
for users familiar with the somewhat analogous `read.nexus` function.

[^3]: By using the commenting mechanism of the Newick format, it is
possible that other software that doesn't also use the comment mechanism
for some other such purpose would be able to successfully parse the tree.
However there is no way to guarantee that this is the case or for the
data format to describe its use.







