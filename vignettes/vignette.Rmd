---
layout: preprint
title: "An Introduction to the RNeXML Package: Semantically Rich I/O for the NeXML Format"
author: 
  - name: Carl Boettiger
    affiliation: cstar
    email: cboettig(at)gmail.com
    footnote: Corresponding author
  - name: Scott Chamberlain
    affiliation: ropensci
  - name: Rutger Vos
    affiliation: NBC
  - name: Hilmar Lapp
    affiliation: NESCent
address: 
  - code: cstar
    address: | 
      Center for Stock Assessment Research, 
      Department of Applied Math and Statistics, 
      University of California, Mail Stop SOE-2,
      Santa Cruz, CA 95064, USA
  - code: NESCent
    address: | 
      National Evolutionary Synthesis Center, Durham, NC, USA
  - code: ropensci
    address: |
      University of California, Berkeley, CA, USA
  - code: NBC
    address: | 
      Naturalis Biodiversity Center, Leiden, the Netherlands

bibliography: components/references.bib
csl: components/methods-in-ecology-and-evolution.csl
documentclass: components/elsarticle

output: 
  pdf_document:
    template: components/elsarticle.latex
    keep_tex: true
    fig_caption: true


---

<!--
%\VignetteEngine{rmarkdown::render}
%\VignetteIndexEntry{An Introduction to the RNeXML Package}
-->


```{r compile-settings, include=FALSE}
library("methods")
library("knitr")
opts_chunk$set(tidy = FALSE, warning = FALSE, message = FALSE, 
               cache = 1, comment = NA, verbose = TRUE)
basename <- gsub(".Rmd", "", knitr:::knit_concord$get('infile')) 
opts_chunk$set(fig.path = paste("figure/", basename, "-", sep=""),
               cache.path = paste("cache/", basename, "/", sep=""))

```


# Introduction to RNeXML


## Getting Started


The current stable version of the `RNeXML` package can be installed from
the CRAN library.

```r
install.packages("RNeXML", dependencies=TRUE)
```


## Reading phylogenetic trees



```{r echo=FALSE}
library(RNeXML)
```

We begin by loading the `RNeXML` package and reading in an example
NeXML file provided with the package, containing two small phylogenetic
trees.

```{r}
library("RNeXML")
nex <- nexml_read("components/trees.xml")
```
The resulting `nex` object is of type `nexml` and is a native R object representation of the NeXML
file. Objects of type `nexml` represent phylogenetic trees as well as 
character traits, and semantic metadata. 

From a `nexml` object, we can extract any phylogenies it contains in the `ape::phylo` format:

```{r}
phy <- get_trees(nex)
```
`RNeXML` can read directly from a URL:

```{r eval=FALSE}
nex <- nexml_read("https://raw.github.com/rvosa/supertreebase/master/data/treebase/S100.xml")
```

## Reading character data 

The function `get_characters()` can then be used to obtain
a `data.frame` with columns as characters and rows as
taxa:

```{r }
nex <- nexml_read("components/comp_analysis.xml")
get_characters(nex)
```


## Writing phylogenetic trees 

Here we write a phylogeny from the `ape::phylo` format out to a NeXML file:

```{r}
data(bird.orders)
nexml_write(bird.orders, file = "birds.xml")
```

The `nexml_write()` function
also allows to add character data:

```{r}
library("geiger")
data(geospiza)
nexml_write(trees = geospiza$phy, characters = geospiza$dat, file="geospiza.xml")
```


The syntax for adding additional data elements is very flexible.
Here we first create a `nexml` object containing the phylogeny data,
and then add the character data to it:

```{r}
geiger_nex <- add_trees(geospiza$phy)
geiger_nex <- add_characters(geospiza$dat, geiger_nex)
```

The data need not share the same taxa.  We can append additional
phylogenies and characters corresponding to different taxa:

```{r}
data(primates)
geiger_nex <- add_trees(primates$phy, geiger_nex)
geiger_nex <- add_characters(primates$dat, geiger_nex)
```

# Metadata


## Writing NeXML metadata



The `add_basic_meta()` function takes as input an existing `nexml` object
(like the other `add_` functions, if none is provided it will create one), and at the time
of this writing any of the following
parameters: `title`, `description`, `creator`, `pubdate`, `rights`, `publisher`,
`citation`.  Other metadata elements and corresponding parameters may
be added in the future.


```{r}
data(bird.orders)
birds <- add_trees(bird.orders)
birds <- add_basic_meta(
  title = "Phylogeny of the Orders of Birds From Sibley and Ahlquist",

  description = "This data set describes the phylogenetic relationships of the
     orders of birds as reported by Sibley and Ahlquist (1990). Sibley
     and Ahlquist inferred this phylogeny from an extensive number of
     DNA/DNA hybridization experiments. The ``tapestry'' reported by
     these two authors (more than 1000 species out of the ca. 9000
     extant bird species) generated a lot of debates.

     The present tree is based on the relationships among orders. The
     branch lengths were calculated from the values of Delta T50H as
     found in Sibley and Ahlquist (1990, fig. 353).",

  citation = "Sibley, C. G. and Ahlquist, J. E. (1990) Phylogeny and
     classification of birds: a study in molecular evolution. New
     Haven: Yale University Press.",

  creator = "Sibley, C. G. and Ahlquist, J. E.",
	nexml=birds)
```

Instead of a literal string, citations can also be provided in R's
`bibentry` type, which is the one in which R package citations are obtained:

```{r}
birds <- add_basic_meta(birds, citation = citation("ape"))
```

A citation to a published paper with a Digital
Object Identifier (DOI) can be provided in the form of the DOI,
which the package `knitcitations` [@Boettiger_2014] can turn into a
formatted citation using. As an example, to add the citation information of the paper that generated the
`geospiza` phylogeny included in the `geiger` package: 

```{r}
library("knitcitations")
geiger_nex <- add_basic_meta(geiger_nex, citation = bib_metadata("10.2307/2408428"))
```



## Taxonomic identifiers

The `taxize_nexml()` function uses the R package `taxize` 
[@Chamberlain_2013] to check each taxon label against the NCBI database.
If a unique match is found, a metadata annotation is added to the taxon
providing the NCBI identification number to the taxonomic unit.


```{r message=FALSE, results='hide'}
birds <- taxize_nexml(birds, "NCBI")
```

If no match is found, the user is warned to check for possible typographic
errors in the taxonomic labels provided. If multiple matches are found,
the user will be prompted to choose between them.


## Custom metadata extensions

We can get a list of namespaces along with their prefixes from the `nexml` object: 

```{r}
prefixes <- get_namespaces(birds)
prefixes["dc"]
```

We create a `meta` element containing this annotation using the `meta` function:

```{r}
modified <- meta(property = "prism:modificationDate", content = "2013-10-04")
```

We can add this annotation to our existing `birds` NeXML file using the
`add_meta()` function.  Because we do not specify a level, it is added to
the root node, referring to the NeXML file as a whole.

```{r}
birds <- add_meta(modified, birds) 
```

The built-in vocabularies are just the tip of the iceberg of established
vocabularies. Here we add an annotation from the `skos` namespace which
describes the history of where the data comes from:

```{r}
history <- meta(property = "skos:historyNote",
  content = "Mapped from the bird.orders data in the ape package using RNeXML")
```

Because `skos` is not in the current namespace list, we add it with a
url when adding this meta element.  We also specify that this annotation
be placed at the level of the `trees` sub-node in the NeXML file.

```{r}
birds <- add_meta(history, 
                birds, 
                level = "trees",
                namespaces = c(skos = "http://www.w3.org/2004/02/skos/core#"))
```


For finer control of the level at which a `meta` element is added,
we will manipulate the `nexml` R object directly using S4 sub-setting,
as shown in the supplement.


Much richer metadata annotation is possible. Later we illustrate how
metadata annotation can be used to extend the base NeXML format to
represent new forms of data while maintaining compatibility with any
NeXML parser. The `RNeXML` package can be easily extended to support
helper functions such as `taxize_nexml` to add additional metadata
without imposing a large burden on the user.


## Reading NeXML metadata

A call to the `nexml` object prints some metadata summarizing the data structure: 

```{r }
birds
```

We can extract all metadata pertaining to the NeXML document as a whole
(annotations of the XML root node, `<nexml>`) with the command

```{r}
meta <- get_metadata(birds) 
```

This returns a named list of available metadata. We can see the kinds
of metadata recorded from the names (showing the first 4):

```{r}
names(meta)[1:4]
```

and can ask for a particular element using the standard list sub-setting
mechanism (i.e. either the name of an element or its numeric position),

```{r}
meta[["dc:title"]]
```

All metadata terms must belong to an explicit *namespace* or vocabulary
that allows a computer to interpret the term precisely. The prefix (before
the `:`) indicates to which vocabulary the term belongs, e.g. `dc` in
this case.  The `get_namespaces` function tells us the definition of
the vocabulary using a link:

```{r}
prefixes <- get_namespaces(birds)
prefixes["dc"]
```

Common metadata can be accessed with a few dedicated functions:

```{r get_citation}
get_citation(birds)
```


```{r get_taxa}
get_taxa(birds)
```

Which returns text from the otu element labels, typically used to define
taxonomic names, rather than text from explicit meta elements.

We can also access metadata at a specific level (or use `level=all`
to extract all meta elements in a list).  Here we show only the first
few results:

```{r} 
otu_meta <- get_metadata(birds, level="otu")
otu_meta[1:4]
```

## RDF manipulation and SPARQL queries 

The most powerful way to take advantage of the machine-readable nature
of the metadata involves the construction of SPARQL queries. This
approach can exploit the reasoning and logical deduction capacity of
formal vocabularies (ontologies). For a proper introduction to SPARQL
queries, see @W3C_2014 or @Hartig_2012).  

The real expressiveness of SPARQL is better illustrated through more
complex examples such as the one shown in the SPARQL demo
(which can be run from R using the command: `demo("sparql", "RNeXML")`).
This demonstration constructs a cladogram based on the taxonomic ranks
provided in the NeXML. SPARQL allows us to make explicit use of ontological
concepts such as manipulating sub-classes (i.e. that "Genus" is a subclass 
of "Family"), or joining multiple predicates (i.e. retrieve the NCBI identifier
of the OTU that has taxon rank of "Order").


## Extending the NeXML standard through metadata annotation.

No data standard can anticipate all the uses and extensions researchers
may one day need. Researchers have repeatedly adapted the existing NEXUS
file format to accommodate encoding new kinds of information, but in the
process break compatibility between different flavors of NEXUS files, with
few reliable methods to distinguish between these flavors.  NeXML provides
a solution to this problem through the use of metadata annotation.

Here we illustrate this process using the example of stochastic character
mapping [@Huelsenbeck_2003]. A stochastic character map is simply
an annotation of the branches on a phylogeny, assigning each section
of each branch to a particular "state" (typically of a morphological
characteristic).

@Bollback_2006 provides a widely used stand-alone software implementation
of this method in the software `simmap`, which modified the standard
Newick tree format to express this additional information. This can
break compatibility with other software, and creates a format that
cannot be interpreted without additional information describing this
convention.  By contrast, the NeXML extension is not only backwards
compatible but contains a precise and machine-readable description of
what it is encoding.






In this example, we illustrate how the additional information required
to define a stochastic character mapping (a `simmap` mapping) in NeXML. 

@Revell_2012 describes the `phytools` package for R, which includes
utilities for reading, manipulating, and writing `simmap` files in R.
In this example, we also show how to define `RNeXML` functions that 
map the R representation used by Revell (an extension of the `ape` class)
into the NeXML extension we have defined by using `RNeXML` functions.

Since a stochastic character map simply assigns different states to
parts of a branch (or edge) on the phylogenetic tree, we can create
a NeXML representation by annotating the `edge` elements with appropriate
`meta` elements.  These elements need to describe the character state
being assigned and the duration (in terms of branch-length) that the edge 
spends in that state (Stochastic character maps are specific to time-calibrated
or ultrametric trees).  

NeXML already defines the `characters` element to handle discrete character traits (`nex:char`)
and the states they can assume (`nex:state`).  We will thus reuse the `characters` element for
this purpose, referring to both the character trait and the states by the ids assigned to them
in that element.  (NeXML's convention of referring to everything by id permits a single canonical
definition of each term, making it clear where additional annotation belongs).  For each edge, we 
need to indicate:

- That our annotation contains a stochastic character mapping reconstruction
- Since many reconstructions are possible for a single edge, we give each reconstruction an id
- We indicate for which character trait we are defining the reconstruction 
- We then indicate which states the character assumes on that edge. 
  For each state realized on the edge, that involves stating: 
    + the state assignment
    + the duration (length of time) for which the edge spends in the given state
    + the order in which the state changes happen (Though we could just assume 
      state transitions are listed chronologically, NeXML suggests making all 
      data explicit, rather than relying on the structure of the data file to
      convey information).  

Thus the annotation for an edge that switches from state `s2` to state 
`s1` of character `cr1` would be constructed like this:

```{r}
 m <- meta("simmap:reconstructions", children = c(
        meta("simmap:reconstruction", children = c(

          meta("simmap:char", "cr1"),
          meta("simmap:stateChange", children = c(
            meta("simmap:order", 1),
            meta("simmap:length", "0.2030"),
            meta("simmap:state", "s2"))),
          
          meta("simmap:char", "cr1"),
          meta("simmap:stateChange", children = c(
            meta("simmap:order", 2),
            meta("simmap:length", "0.0022"),
            meta("simmap:state", "s1")))
          ))))
```

Of course writing out such a definition manually becomes tedious quickly. Because
these are just R commands, we can easily define a function that can loop over an
assignment like this for each edge, extracting the appropriate order, length and
state from an existing R object such as that provided in the `phytools` package.  
Likewise, it is straightforward to define a function that reads this data using
the `RNeXML` utilities and converts it back to the `phytools` package. The full
implementation of this mapping can be seen in the `simmap_to_nexml()` and the
`nexml_to_simmap()` functions provided in the `RNeXML` package.  

As the code indicates, the key step is simply to define the data in meta elements. In 
so doing, we have defined a custom namespace, `simmap`, to hold our variables.  This
allows us to provide a URL with more detailed descriptions of what each of these 
elements mean:

```{r}
nex <- add_namespaces(c(simmap = "https://github.com/ropensci/RNeXML/tree/master/inst/simmap.md"))
```

At that URL we have posted a simple description of each term. 

Using this convention we can generate NeXML files containing `simmap`
data, read those files into R, and convert them back into the `phytools`
package format. These simple functions serve as further illustration of
how `RNeXML` can be used to extend the NeXML standard.  We illustrate
their use briefly here, starting with  loading a `nexml` object containing
a `simmap` reconstruction into R:


```{r}
data(simmap_ex)
```

The `get_trees()` function can be used to return an `ape::phylo` tree as
usual.  `RNeXML` automatically detects the `simmap` reconstruction data
and returns includes this in a `maps` element of the `ape::phylo` object,
for use with other `phytools` functions.

```{r}
phy <- nexml_to_simmap(simmap_ex)
```

We can then use various functions from `phytools` designed for `simmap`
objects [@Revell_2012], such as the plotting function:

```{r Figure1, fig.cap="Stochastic character mapping on a phylogeny, as generated by the phytools package after parsing the simmap-extended NeXML."}
library("phytools")
plotSimmap(phy)
```

Likewise, we can convert the object back in the NeXML format and write
it out to file to be read by other users. 

```{r}
nex <- simmap_to_nexml(phy) 
nexml_write(nex, "simmap.xml")
```

Though other NeXML parsers (for instance, for Perl or Python) have
not been written explicitly to express `simmap` data, those parsers will
nonetheless be able to successfully parse this file and expose the `simmap`
data to the user.



# Software reuse and support

The `RNeXML` package is available through the CRAN repository under
a CC0 license. At the time of writing, the current version is `r packageDescription("RNeXML", fields="Version")`. 
The current development
branch can be found on Github at [https://github.com/ropensci/RNeXML]().
See the NEWS file for changes in recent versions. Users are encouraged
to submit bug reports or feature requests in the issues log.  Contact
`ropensci-discuss@googlegroups.com` or the package maintainer for help,
or email the phylogenetics R users group list at `r-sig-phylo@r-project.org`.  


There are many promising directions for further development of the
`RNeXML` package.  The project's [Milestones page](https://github.com/ropensci/RNeXML/issues/milestones) page provides a list of
steps currently planned or under consideration.  In particular, these
milestones include increased support for interactive mode of entering data
(wizards), conversions to and from other existing R phylogenetics formats
such those found in the `phylobase` package [@phylobase],
and support for integration of semantics defined through the
Web Ontology language (OWL), as discussed in the Challenges section.



# Implementation, architecture and quality control


The `RNeXML` package is built for the NeXML Schema, [version 2009],
using the R software environment and the XML package for parsing and
generating XML [@Temple_Lang_2013],  provides conversions into
the popular `phylo` format provided by the `ape` package [@Paradis_2004],  
`RNeXML` can automatically check taxonomic names and add taxonomic
identifiers when generating NeXML using methods from the `taxize` package [@Chamberlain_2014].
Unique identifiers are provided with the `uuid` package [@Urbanek_2014],
and internet interfaces by the `httr` package [@Wickham_2014]. The
packages `plyr` and `reshape2` [@Wickham_2011; Wickham_2007] are also imported for internal methods.


The `RNeXML` package performs several levels of validation on NeXML files
written from or read into R: validating the XML, and validating against
the current NeXML schema, and performing additional checks through the 
NeXML online validation tool for elements that cannot be enforced by
schema validation alone.  Validation serves to improve consistency in
data encoding which facilitates the use of NeXML across a wide variety
of platforms and software.  A lack of a consistent standard and validation
mechanism has continually plagued the current NEXUS standard and made 
interoperability difficult [@Vos_2012].  

Several mechanisms are in place to evaluate the quality of the `RNeXML`
package functions themselves.  In addition to the examples from the
documentation and the automated package checks provided for the R system,
the `RNeXML` package includes a complete test suite using the `testthat`
package [@Wickham_2011a]. Package development on Github includes continuous 
integration through the `travis` platform, in which the full test suite
is run every time the code is changed.  This not only gives users confidence
that the development copy can be successfully installed, but should assist
other developers seeking to contribute to the package to test that their proposed 
changes have not negatively impacted any of the existing code base.  



```{r cleanup, include=FALSE, cache=FALSE}
unlink("simmap.xml")
unlink("birds.xml")
unlink("geospiza.xml")
unlink("rdf_meta.xml")
```
